import torch
import torch.nn as nn
from loss_function.DICE import DiceLoss, DiceLoss_3class
from torch.nn import functional as F


class recall_Loss(nn.Module):
    def __init__(self):
        super(recall_Loss, self).__init__()

    def forward(self, input, target):
        N = target.size(0)
        smooth = 0.2
        input_flat = input.view(N, -1)
        target_flat = target.view(N, -1)
        intersection = input_flat * target_flat
        recall = (intersection.sum(1) + smooth) / (target_flat.sum(1) + smooth)
        recall = recall.sum() / N
        return 1 - recall


class dice_recall_loss(nn.Module):
    def __init__(self):
        super(dice_recall_loss, self).__init__()
        self.r_loss = recall_Loss()
        self.d_loss = DiceLoss()

    def forward(self, input, target):
        loss1 = self.r_loss(input, target)
        loss2 = self.d_loss(input, target)
        return 0.75 * loss1 + 0.25 * loss2

class dice_BCE_loss(nn.Module):
    def __init__(self, bce_weight, dice_weight):
        super(dice_BCE_loss, self).__init__()
        self.b_loss = nn.BCELoss()
        self.d_loss = DiceLoss()
        self.bce_weight = bce_weight
        self.dice_weight = dice_weight

    def forward(self, input, target):
        loss1 = self.b_loss(input, target)
        loss2 = self.d_loss(input, target)
        return self.bce_weight*loss1 + self.dice_weight*loss2

def dice_loss(input, target):
    input = torch.sigmoid(input)
    smooth = 1.0
    iflat = input.view(-1)
    tflat = target.view(-1)
    intersection = (iflat * tflat).sum()
    return ((2.0 * intersection + smooth) / (iflat.sum() + tflat.sum() + smooth))


class FocalLoss(nn.Module):
    def __init__(self, gamma):
        super().__init__()
        self.gamma = gamma

    def forward(self, input, target):
        if not (target.size() == input.size()):
            raise ValueError("Target size ({}) must be the same as input size ({})"
                             .format(target.size(), input.size()))
        max_val = (-input).clamp(min=0)
        loss = input - input * target + max_val + \
            ((-max_val).exp() + (-input - max_val).exp()).log()
        invprobs = F.logsigmoid(-input * (target * 2.0 - 1.0))
        loss = (invprobs * self.gamma).exp() * loss
        return loss.mean()


class MixedLoss(nn.Module):
    def __init__(self, alpha, gamma):
        super().__init__()
        self.alpha = alpha
        self.focal = FocalLoss(gamma)

    def forward(self, input, target):
        loss = self.alpha*self.focal(input, target) - torch.log(dice_loss(input, target))
        return loss.mean()

if __name__ == '__main__':
    a = torch.sigmoid(torch.rand((3, 1, 512, 512)))
    b = torch.sigmoid(torch.rand((3, 1, 512, 512)))
    l = MixedLoss(alpha=10, gamma=2)
    loss = l(a, b)
    print(loss)
    

